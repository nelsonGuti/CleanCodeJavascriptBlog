---
title: "Funciones"
description: "Funciones y Clean Code JS."
date: 2019-08-12
order: 3
lang: "es"
---

## Funciones

### Argumentos de una funci√≥n (idealmente 2 o menos)

Limitar la cantidad de par√°metros de una funci√≥n es incre√≠blemente importante
porque hacen que _las pruebas_ de tu funci√≥n sean m√°s sencillas. Tener m√°s de tres
lleva a una locura combinatoria donde tienes que probar toneladas de casos
diferentes con cada argumento por separado.

El caso ideal es usar uno o dos argumentos, tres... deben evitarse si es posible.
Cualquier n√∫mero superior a eso, deber√≠a ser agrupado. Por lo general, si tienes
m√°s de dos argumentos, tu funci√≥n debe de estar haciendo demasiadas cosas. En los
casos donde no es as√≠, la mayor√≠a de las veces un objeto de nivel superior ser√°
suficiente como un argumento _par√°metro objeto_.

Ya que Javascript te permite crear objetos al vuelo sin tener que hacer mucho
c√≥digo repetitivo en una clase, puedes usar un objeto en caso de estar necesitando
muchos par√°metros.

Para indicar que propiedades espera la funci√≥n, puedes usar las funcionalidades
de desestructuraci√≥n que nos ofrece ES2015/ES6. √âstas tienen algunas ventajas:

1. Cuando alguien mira la firma de la funci√≥n, sabe inmediatamente que propiedades
   est√°n siendo usadas
2. La desetructuraci√≥n tambi√©n clona los valores primitivos especificados del `objeto argumento`
   pasado a la funci√≥n. Esto puede servir de ayuda para prevenir efectos adversos.
   _Nota: Los objetos y los arrays que son desestructurados del objeto par√°metro NO son clonados._
3. Las herramientas lintera o _linterns_ pueden avisarte de qu√© propiedades del
   objeto par√°metro no est√°n en uso. _Cosa que es imposile sin desestructuraci√≥n._

**üôÖ‚Äç Mal:**

```javascript
function crearMenu(titulo, cuerpo, textoDelBoton, cancelable) {
  // ...
}
```

**üë®‚Äçüè´ Bien:**

```javascript
function crearMenu({ titulo, cuerpo, textoDelBoton, cancelable }) {
  // ...
}

crearMenu({
  titulo: "Foo",
  cuerpo: "Bar",
  textoDelBoton: "Baz",
  cancelable: true
});
```

### Las funciones deber√≠an hacer una cosa

De lejos, es la regla m√°s importante en la ingenier√≠a del software. Cuando
las funciones hacen m√°s de una cosa, son dif√≠ciles de componer y _testear_
entre otras cosas. Si isolamos las funciones por acciones, √©stas pueden ser
modificadas y mantenidas con mayor facilidad y tu c√≥digo ser√° mucho m√°s limpio.
De toda esta gu√≠a... si has de aprender algo, que sea esto. Ya estar√°s mmuy
por delante de muchos desarrolladores de software.

**üôÖ‚Äç Mal:**

```javascript
function enviarCorreoAClientes(clientes) {
  clientes.forEach(cliente => {
    const historicoDelCliente = baseDatos.buscar(cliente);
    if (historicoDelCliente.estaActivo()) {
      enviarEmail(cliente);
    }
  });
}
```

**üë®‚Äçüè´ Bien:**

```javascript
function enviarCorreoClientesActivos(clientes) {
  clientes.filter(esClienteActive).forEach(enviarEmail);
}

function esClienteActivo(cliente) {
  const historicoDelCliente = baseDatos.buscar(cliente);
  return historicoDelCliente.estaActivo();
}
```

### Los nombres de las funciones deber√≠an decir lo que hacen

**üôÖ‚Äç Mal:**

```javascript
function a√±adirAFecha(fecha, mes) {
  // ...
}

const fecha = new Date();

// Es dif√≠cil saber que se le est√° a√±adiendo a la fecha en este caso
a√±adirAFecha(fecha, 1);
```

**üë®‚Äçüè´ Bien:**

```javascript
function a√±adirMesAFecha(mes, fecha) {
  // ...
}

const fecha = new Date();
a√±adirMesAFecha(1, fecha);
```

### Las funciones deber√≠an ser √∫nicamente de un nivel de abstracci√≥n

Cuando tienes m√°s de un nivel de abstracci√≥n, tu funci√≥n normalmente est√°
hacicendo demasiado. Separarla en funciones m√°s peque√±as te ayudar√° a poder
reutilizar c√≥digo y te facilitar√° el _testear_ √©stas.

**üôÖ‚Äç Mal:**

```javascript
function analizarMejorAlternativaJavascript(codigo) {
  const EXPRESIONES_REGULARES = [
    // ...
  ];

  const declaraciones = codigo.split(" ");
  const tokens = [];
  EXPRESIONES_REGULARES.forEach(EXPRESION_REGULAR => {
    declaraciones.forEach(declaracion => {
      // ...
    });
  });

  const ast = [];
  tokens.forEach(token => {
    // lex...
  });

  ast.forEach(nodo => {
    // parse...
  });
}
```

**üë®‚Äçüè´ Bien:**

```javascript
function analizarMejorAlternativaJavascript(codigo) {
  const tokens = tokenize(codigo);
  const ast = lexer(tokens);
  ast.forEach(nodo => {
    // parse...
  });
}

function tokenize(codigo) {
  const EXPRESIONES_REGULARES = [
    // ...
  ];

  const declaraciones = codigo.split(" ");
  const tokens = [];
  EXPRESIONES_REGULARES.forEach(EXPRESION_REGULAR => {
    declaraciones.forEach(declaracion => {
      tokens.push(/* ... */);
    });
  });

  return tokens;
}

function lexer(tokens) {
  const ast = [];
  tokens.forEach(token => {
    ast.push(/* ... */);
  });

  return ast;
}
```

### Elimina c√≥digo duplicado

Haz todo lo posible para evitar duplicaci√≥n de c√≥digo. Duplicar c√≥digo es
malo porque significa que para editar un comportamiento... tendr√°s que modificarlko
en m√°s de un sitio. ¬øY no queremos trabajar de m√°s, verdad?

Como caso pr√°ctico: Imagina que tienes un restaurante. Llevas el registro del
inventario: Todos tus tomates, cebollas, ajos, especies, etc... Si tuvieras m√°s
de una lista que tuvieras que actualizar cada vez que sirves un tomate o usas
una especie, ser√≠a m√°s f√°cil de cometer errores, adem√°s de todo el tiempo perdido.
Si solo tienes una, la posibilidad de cometer una error se reduce a √©sta!

A menudo tienes c√≥digo duplicado porque tienes dos o m√°s cosas ligeramente
diferentes, que tienen mucho en com√∫n, pero sus diferencias te obligan a tener
ese c√≥digo de m√°s. Borrar la duplicaci√≥n de c√≥digo significa crear una abstracci√≥n
que pueda manejar este conjunto de cosas diferentes con una sola funci√≥n/m√≥dulo/clase.

Hacer que la abstracci√≥n sea correcta es fundamental y a veces bastante complejo.
Es por eso que debes seguir los Principios `SOLID` establecidos en la secci√≥n _Clases_.
Las malas abstracciones pueden ser peores que el c√≥digo duplicado. ¬°As√≠ que ten cuidado!
Dicho esto, si se puede hacer una buena abstracci√≥n, ¬°H√°zla! Evita repetirte
porque de lo contrario, como hemos comentado anteriormente, te ver√°s editando
en m√°s de un lugar para modificar un comportamiento.

**üôÖ‚Äç Mal:**

```javascript
function mostrarListaDesarrolladores(desarrolladores) {
  desarrolladores.forEach(desarrollador => {
    const salarioEsperado = desarrollador.calcularSalarioEsperado();
    const experiencia = desarrollador.conseguirExperiencia();
    const enlaceGithub = desarrollador.conseguirEnlaceGithub();
    const datos = {
      salarioEsperado,
      experiencia,
      enlaceGithub
    };

    render(datos);
  });
}

function mostrarListaJefes(jefes) {
  jefes.forEach(jefe => {
    const salarioEsperado = desarrollador.calcularSalarioEsperado();
    const experiencia = desarrollador.conseguirExperiencia();
    const experienciaLaboral = jefe.conseguirProyectosMBA();
    const data = {
      salarioEsperado,
      experiencia,
      experienciaLaboral
    };

    render(data);
  });
}
```

**üë®‚Äçüè´ Bien:**

```javascript
function mostrarListaEmpleados(empleados) {
  empleados.forEach(empleado => {
    const salarioEsperado = empleado.calcularSalarioEsperado();
    const experiencia = empleado.conseguirExperiencia();

    const datos = {
      salarioEsperado,
      experiencia
    };

    switch (empleado.tipo) {
      case "jefe":
        datos.portafolio = empleado.conseguirProyectosMBA();
        break;
      case "desarrollador":
        datos.enlaceGithub = empleado.conseguirEnlaceGithub();
        break;
    }

    render(datos);
  });
}
```

### Asigna objetos por defecto con Object.assign

**üôÖ‚Äç Mal:**

```javascript
const configuracionMenu = {
  titulo: null,
  contenido: "Bar",
  textoBoton: null,
  cancelable: true
};

function crearMenu(config) {
  config.titulo = config.titulo || "Foo";
  config.contenido = config.contenido || "Bar";
  config.textoBoton = config.textoBoton || "Baz";
  config.cancelable =
    config.cancelable !== undefined ? config.cancelable : true;
}

crearMenu(configuracionMenu);
```

**üë®‚Äçüè´ Bien:**

```javascript
const configuracionMenu = {
  titulo: "Order",
  // El usuario no incluy√≥ la clave 'contenido'
  textoBoton: "Send",
  cancelable: true
};

function crearMenu(configuracion) {
  configuracion = Object.assign(
    {
      titulo: "Foo",
      contenido: "Bar",
      textoBoton: "Baz",
      cancelable: true
    },
    configuracion
  );

  // configuracion ahora es igual a: {titulo: "Order", contenido: "Bar", textoBoton: "Send", cancelable: true}
  // ...
}

crearMenu(configuracionMenu);
```

### No utilices banderas o flags

Las banderas o _flags_ te indican de que esa funci√≥n hace m√°s de una cosa. Ya
que como vamos repitiendo, nuestras funciones solo deber√≠an hacer una cosa, separa
esa l√≥gica que es diferenciada por la bandera o _flag_ en una nueva funci√≥n.

**üôÖ‚Äç Mal:**

```javascript
function crearFichero(nombre, temporal) {
  if (temporal) {
    fs.create(`./temporal/${nombre}`);
  } else {
    fs.create(nombre);
  }
}
```

**üë®‚Äçüè´ Bien:**

```javascript
function crearFichero(nombre) {
  fs.create(nombre);
}

function crearFicheroTemporal(nombre) {
  crearFichero(`./temporal/${nombre}`);
}
```

### Evita los efectos secundarios (parte 1)

Una funci√≥n produce un efecto adverso/colateral si hace otra cosa que recibir
un par√°metro de entrada y retornar otro valor o valores. Un efecto adverso puede
ser escribir un fichero, modificar una variable global o accidentalmente enviar
todo tu dinero a un desconocido.

Ahora bien, a veces necesitamos efectos adversos en nuestros programas. Como
en el ejemplo anterior, quiz√°s necesitas escribir en un fichero. As√≠ pues, lo que
queremos es centralizar donde se hace esta acci√≥n. No queremos que esta l√≥gica
la tengamos que escribir en cada una de las funciones o clases que van a utilizarla.
Para eso, la encapsularemos en un servicio que haga eso. S√≥lo eso.

El objetivo principal es evitar errores comunes como compartir el estado entre objetos
sin ninguna estructura, usando tipos de datos mutables que pueden ser escritos por cualquier cosa
y no centralizar donde se producen sus efectos secundarios. Si puedes hacer esto, ser√°s
m√°s feliz que la gran mayor√≠a de otros programadores.

**üôÖ‚Äç Mal:**

```javascript
// Variable Global referenciada por la siguiente funci√≥n
// Si tuvieramos otra funci√≥n que usara ese nombre, podr√≠a ser un array y lo estar√≠amos rompiendo
// If we had another function that used this name, now it'd be an array and it could break it.
let nombre = 'Ryan McDermott';

function separarEnNombreYApellido) {
  nombre = nombre.split(' ');
}

separarEnNombreYApellido();

console.log(nombre); // ['Ryan', 'McDermott'];
```

**üë®‚Äçüè´ Bien:**

```javascript
function separarEnNombreYApellido) {
  return nombre.split(' ');
}

const nombre = 'Ryan McDermott';
const nuevoNombre = separarEnNombreYApellidoe);

console.log(nombre); // 'Ryan McDermott';
console.log(nuevoNombre); // ['Ryan', 'McDermott'];
```

### Evita los efectos secundarios (parte 2)

En JavaScript, los primitivos se pasan por valor y los objetos / arrays se pasan por
referencia. En el caso de objetos y arrays, si su funci√≥n hace un cambio como por ejemplo,
a√±adiendo un elemento al array que representa el carrito de la compra, entonces cualquier
otra funci√≥n que use ese array `carrito` se ver√° afectada por esta modificaci√≥n.
Eso puede ser genial, sin embargo, tambi√©n puede ser malo. Imaginemos una mala situaci√≥n:

El usuario hace clic en el bot√≥n "Comprar", que llama a una funci√≥n de "compra" que
genera una petici√≥n de red y env√≠a el array `carrito` al servidor. Dada una mala
conexi√≥n de red, la funci√≥n `comprar` tiene que seguir reintentando la solicitud.
Ahora, ¬øQu√© pasa si mientras tanto el usuario hace clic accidentalmente en el bot√≥n
_"Agregar al carrito"_ en un elemento que realmente no quiere, antes de que comience
la solicitud de red? Si esto sucede y la solicitud de red comienza, entonces esa
funci√≥n de compra enviar√° el art√≠culo agregado accidentalmente porque tiene una
referencia al objeto dado que la funci√≥n `a√±adirObjetoAlCarrito` modific√≥ el `carrito`
agregando un elemento que no deseado.

Una buena soluci√≥n para `a√±adirObjetoAlCarrito` podr√≠a ser clonar el `carrito`, editarlo,
y retornar la copia. Esto nos asegura que ninguna otra funci√≥n tiene referencia al
objeto con los campos modificados. As√≠ pues, ninguna otra funci√≥n se ver√° afectada
por nuestros cambios.

Dos advertencias que mencionar para este enfoque:

1. Puede haber casos en los que realmente desee modificar el objeto de entrada,
   pero cuando adopte esta pr√°ctica de programaci√≥n encontrar√° que esos casos son
   bastante raros ¬°La mayor√≠a de las cosas se pueden refactorizar para que no tengan
   efectos secundarios!

2. Clonar objetos grandes puede ser muy costosa en t√©rminos de rendimiento.
   Por suerte, en la pr√°ctica, esto no es un gran problema dado que hay
   [buenas librer√≠as](https://facebook.github.io/immutable-js/) que permiten este
   tipo de enfoque de programaci√≥n. Es r√°pido y no requiere tanta memoria como te
   costar√≠a a ti clonar manualmente los arrays y los objetos.

**üôÖ‚Äç Mal:**

```javascript
const a√±adirObjetoAlCarrito = (carrito, objeto) => {
  carrito.push({ objeto, fecha: Date.now() });
};
```

**üë®‚Äçüè´ Bien:**

```javascript
const a√±adirObjetoAlCarrito = (carrito, objeto) => {
  return [...carrito, { objeto, fecha: Date.now() }];
};
```

### No escribas en variables globales

La contaminaci√≥n global es una mala pr√°ctica en JavaScript porque podr√≠a chocar
con otra librer√≠a y usuarios usuarios de tu API no ser√≠an conscientes de ello hasta
que tuviesen un error en producci√≥n. Pensemos en un ejemplo: ¬øQu√© pasar√≠a si quisieras
extender los arrays de Javascript para tener un m√©todo `diff` que pudiera ense√±ar la
diferencia entre dos arrays? Podr√≠as escribir tu nueva funci√≥n en el `Array.prototype`,
pero podr√≠a chocar con otra librer√≠a que intent√≥ hacer lo mismo. ¬øQu√© pasa si esa otra
librer√≠a estaba usando `diff` para encontrar la diferencia entre los elementos primero
y √∫ltimo de una matriz? Tendr√≠amos problemas... Por eso, ser√≠a mucho mejor usar las
clases ES2015 / ES6 y simplemente extender el `Array` global.

**üôÖ‚Äç Mal:**

```javascript
Array.prototype.diff = function diff(matrizDeComparaci√≥n) {
  const hash = new Set(matrizDeComparaci√≥n);
  return this.filter(elemento => !hash.has(elemento));
};
```

**üë®‚Äçüè´ Bien:**

```javascript
class SuperArray extends Array {
  diff(matrizDeComparaci√≥n) {
    const hash = new Set(matrizDeComparaci√≥n);
    return this.filter(elemento => !hash.has(elemento));
  }
}
```

### Da prioridad a la programaci√≥n funcional en vez de la programaci√≥n imperativa

Javascript no es un lenguage funcional en la misma medida que lo es Haskell, pero
tiene aspectos que lo favorecen. Los lenguages funcionales pueden ser m√°s f√°ciles
y limpios de _testear_. Favorece este estilo de programaci√≥n siempre que puedas.

**üôÖ‚Äç Mal:**

```javascript
const datosSalidaProgramadores = [
  {
    nombre: "Uncle Bobby",
    liniasDeCodigo: 500
  },
  {
    nombre: "Suzie Q",
    liniasDeCodigo: 1500
  },
  {
    nombre: "Jimmy Gosling",
    liniasDeCodigo: 150
  },
  {
    nombre: "Gracie Hopper",
    liniasDeCodigo: 1000
  }
];

let salidaFinal = 0;

for (let i = 0; i < datosSalidaProgramadores.length; i++) {
  salidaFinal += datosSalidaProgramadores[i].liniasDeCodigo;
}
```

**üë®‚Äçüè´ Bien:**

```javascript
const datosSalidaProgramadores = [
  {
    nombre: "Uncle Bobby",
    liniasDeCodigo: 500
  },
  {
    nombre: "Suzie Q",
    liniasDeCodigo: 1500
  },
  {
    nombre: "Jimmy Gosling",
    liniasDeCodigo: 150
  },
  {
    nombre: "Gracie Hopper",
    liniasDeCodigo: 1000
  }
];

const salidaFinal = datosSalidaProgramadores
  .map(salida => salida.linesOfCode)
  .reduce((totalLinias, linias) => totalLinias + linias);
```

### Encapsula los condicionales

**üôÖ‚Äç Mal:**

```javascript
if (fsm.state === "cogiendoDatos" && estaVacio(listaNodos)) {
  // ...
}
```

**üë®‚Äçüè´ Bien:**

```javascript
function deberiaMostrarSpinner(fsm, listaNodos) {
  return fsm.state === "cogiendoDatos" && estaVacio(listaNodos);
}

if (deberiaMostrarSpinner(fsmInstance, listNodeInstance)) {
  // ...
}
```

### Evita condicionales negativos

**üôÖ‚Äç Mal:**

```javascript
function noEstaElNodoPresente(node) {
  // ...
}

if (!noEstaElNodoPresente(node)) {
  // ...
}
```

**üë®‚Äçüè´ Bien:**

```javascript
function estaElNodoPresente(node) {
  // ...
}

if (estaElNodoPresente(node)) {
  // ...
}
```

### Evita condicionales

Esto parece una tarea imposible. Al escuchar esto por primera vez, la mayor√≠a de
la gente dice _"¬øcomo voy a ser capaz de hacer cosas sin un `if`"?_ La respuesta a eso,
es que deber√≠as usar polimorfismo para conserguir lo mismo en la gran mayor√≠a de los
casos. La segunda pregunta que normalmente la gente hace es, _¬øBueno est√° bien pero
para que voy a querer hacerlo?_ La respuesta es uno de los conceptos previos que
hemos visto de _C√≥digo limpio_: Una funci√≥n deber√≠a hacer √∫nicamente una cosa.
Cuando tienes una funci√≥n o clase que posee un `if`, le est√°s diciendo al usuario
que tu funci√≥n est√° haciendo m√°s de una cosa. Recuerda, tan s√≥lo una cosa.

**üôÖ‚Äç Mal:**

```javascript
class Avion {
  // ...
  obtenerAlturaDeVuelo() {
    switch (this.tipo) {
      case "777":
        return this.cogerAlturaMaxima() - this.conseguirNumeroPasajeros();
      case "Air Force One":
        return this.cogerAlturaMaxima();
      case "Cessna":
        return this.cogerAlturaMaxima() - this.getFuelExpenditure();
    }
  }
}
```

**üë®‚Äçüè´ Bien:**

```javascript
class Avion {
  // ...
}

class Boeing777 extends Avion {
  // ...
  obtenerAlturaDeVuelo() {
    return this.cogerAlturaMaxima() - this.conseguirNumeroPasajeros();
  }
}

class AirForceOne extends Avion {
  // ...
  obtenerAlturaDeVuelo() {
    return this.cogerAlturaMaxima();
  }
}

class Cessna extends Avion {
  // ...
  obtenerAlturaDeVuelo() {
    return this.cogerAlturaMaxima() - this.getFuelExpenditure();
  }
}
```

### Evita el control de tipos (parte 1)

Javascript es un lenguaje no tipado. Esto significa que las funciones pueden recibir
cualquier tipo como argumento. A veces, nos aprovechamos de eso... y es por eso, que
se vuelve muy tentador el controlar los tipos de los argumentos de la funci√≥n. Hay
algunas soluciones para evitar esto. La primera, son APIs consistentes. Por API se
entiende de que manera nos comunicamos con ese m√≥dulo/funci√≥n.

**üôÖ‚Äç Mal:**

```javascript
function viajarATexas(vehiculo) {
  if (vehiculo instanceof Bicicleta) {
    vehiculo.pedalear(this.ubicacionActual, new Localizacion("texas"));
  } else if (vehiculo instanceof Car) {
    vehiculo.conducir(this.ubicacionActual, new Localizacion("texas"));
  }
}
```

**üë®‚Äçüè´ Bien:**

```javascript
function viajarATexas(vehiculo) {
  vehiculo.mover(this.ubicacionActual, new Localizacion("texas"));
}
```

### Evita control de tipos (parte 2)

Si est√°s trabajando con los tipos primitivos como son las `cadenas` o `enteros`,
y no puedes usar polimorfismo pero a√∫n ves la necesidad del control de tipos,
deber√≠as considerar `Typescript`. Es una excelente alternativa al `Javascript`
convencional que nos aporta control de tipos de manera est√°tica entre otras
muchas cosas. El problema de controlar manualmente el tipado en `Javascript` es
que para hacerlo bien, necesitamos a√±adir mucho c√≥digo a bajo nivel que afecta a
la legibilidad del c√≥digo. Mant√©n tu c√≥digo `Javascript` limpio, escribe _tests_
y intenta tener revisiones de c√≥digo. Si no, intenta cubrir el m√°ximo de cosas con
`Typescript` que como ya hemos dicho, es una muy buena alternativa.

**üôÖ‚Äç Mal:**

```javascript
function combina(valor1, valor2) {
  if (
    (typeof valor1 === "number" && typeof valor2 === "number") ||
    (typeof valor1 === "string" && typeof valor2 === "string")
  ) {
    return valor1 + valor2;
  }

  throw new Error("Deber√≠a ser una cadena o n√∫mero");
}
```

**üë®‚Äçüè´ Bien:**

```javascript
function combina(valor1, valor2) {
  return valor1 + valor2;
}
```

### No optimizes al m√°ximo

Los navegadores modernos hacen mucha optimizaci√≥n por detr√°s en tiempo de ejecuci√≥n.
Muchas veces, al interntar optimizar tu c√≥digo... est√°s perdiendo el tiempo.
[Esta es una buena documentaci√≥n](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers)
para ver donde falta optimizaci√≥n. Pon el foco en √©stas hasta que est√©n arregladas/hechas
si es que se pueden.

**üôÖ‚Äç Mal:**

```javascript
// En los navegadores antiguos, cada iteraci√≥n en la que `list.length` no est√© cacheada
// podr√≠a ser costosa por el rec√°lculo de este valor. En los modernos, ya est√° optimizado
for (let i = 0, tama√±o = lista.length; i < tama√±o; i++) {
  // ...
}
```

**üë®‚Äçüè´ Bien:**

```javascript
for (let i = 0; i < lista.length; i++) {
  // ...
}
```

### Borra c√≥digo in√∫til

El c√≥digo in√∫til es tan malo como la duplicaci√≥n. No hay raz√≥n alguna para
mantenerlo en tu c√≥digo. Si no est√° siendo usado por nadie, ¬°B√≥rralo! Siempre
estar√° disponible en sistema de versiones para el caso que lo necesites.

**üôÖ‚Äç Mal:**

```javascript
function antiguoModuloDePeticiones(url) {
  // ...
}

function nuevoModuloDePeticiones(url) {
  // ...
}

const peticion = nuevoModuloDePeticiones;
calculadorDeInventario("manzanas", peticion, "www.inventory-awesome.io");
```

**üë®‚Äçüè´ Bien:**

```javascript
function nuevoModuloDePeticiones(url) {
  // ...
}

const peticion = nuevoModuloDePeticiones;
calculadorDeInventario("manzanas", peticion, "www.inventory-awesome.io");
```
